#!/bin/python

# ======================================================= IMPORTS & MODULE SETUP


import os
import sys
import signal
import subprocess as sh
from types import FrameType
from functools import partial

from CatalisLogger.logging import Logger

import json
from time import sleep, strftime, gmtime
import apsw, apsw.bestpractice
from pyModbusTCP.client import ModbusClient


# initialize apsw
apsw.bestpractice.apply((
	apsw.bestpractice.connection_busy_timeout,
	apsw.bestpractice.connection_enable_foreign_keys,
	apsw.bestpractice.connection_dqs
))


# ================================================================= CONFIG SETUP


# create config object
class CFG:
	FSTYPE 			= os.environ.get("CATALIS_FSTYPE", 					"vfat")
	LABEL_PREFIX 	= os.environ.get("CATALIS_LABEL_PREFIX", 			"DATA-HMI")
	MOUNTPOINT 		= os.environ.get("CATALIS_MOUNTPOINT", 				"/srv/CatalisDATA/")
	DB_SUBDIR 		= os.environ.get("CATALIS_DB_SUBDIR", 				"current/")
	DB_PATTERN 		= os.environ.get("CATALIS_DB_PATTERN", 				"polldata-hmi$HMID")
	HMI_HOST 		= os.environ.get("CATALIS_HMI_HOST", 				"192.168.1.2")
	POLLING_FREQ 	= os.environ.get("CATALIS_POLLING_FREQUENCY", 		"5")
	POLL_RETRY_INT 	= os.environ.get("CATALIS_POLL_RETRY_INTERVAL", 	"10")


# ================================================================= DATA PACKETS


# data packet definition class
class PacketDefinition:
	def __init__(self, type:str, addresses:list[str]):
		self.type = type
		self.addresses = addresses


# =================================================== POLL DATA DATABASE MANAGER


class PollDB:
	def __init__(self, hmid:str):
		self.dbpath =  os.path.join(CFG.MOUNTPOINT, CFG.DB_SUBDIR, (f"{CFG.DB_PATTERN}.sqlite3").replace("$HMID", hmid))
		
		try: self._connection = apsw.Connection(self.dbpath)		
		except apsw.CantOpenError as e: raise e # failed to initialize database


	# write poll data to database
	def write(self, type:str, data:str) -> None:
		try:
			timestamp = strftime("%s", gmtime())
			self._connection.execute("INSERT INTO packets (timestamp, type, data) VALUES (?,?,?);", (timestamp, type, data))

		# failed to write to database
		except apsw.ReadOnlyError as e0:			
			try: # check if can open db, if yes assume permissions error
				test = apsw.Connection(self._connection.filename, flags=apsw.SQLITE_OPEN_READWRITE)
				raise e0
				
			except apsw.CantOpenError as e1: # otherwise, assume database deleted
				raise e1


# ====================================================================== POLLING
 

def poll(client:ModbusClient, definition:PacketDefinition) -> dict:
	try: return {str(addr):client.read_holding_registers(addr)[0] for addr in definition.addresses}
	except TypeError as e: raise e # if None value exists in data (ie. failed to retrieve a register)


# ================================================================== MAIN DAEMON


# daemon
def daemon() -> None:
	# initialize logger 
	logger = Logger(logfile=f"/var/log/catalis/poll-{strftime('%d%m%Y-%H%M%S', gmtime())}.log")

	# register custom standard termination exit handler
	signal.signal(signal.SIGTERM, partial(exit_clean, logger))

	# write to journalctl log
	sh.run(f"echo 'Daemon started. Logging to {logger}.'", shell=True)

	# get filesytem label
	fs_label = sh.getoutput(f"lsblk -o label /dev/{sys.argv[1]} | tail -1")

	# print logging preamble
	logger.print(f"Welcome to the Catalis Cloud HMI Poller Daemon")
	logger.print(f"Session date: {strftime('%F', gmtime())} (GMT)")
	logger.print(f"Filesystem label: {fs_label}")
	logger.print(f"Mount point: {CFG.MOUNTPOINT}")
	logger.print(f"HMI TCP/IP host address: {CFG.HMI_HOST}\n")


	# initialize database	
	logger.log("(init) <1/2>: Connecting to database... ", endline=False)

	try: 
		db = PollDB(hmid=fs_label.strip(CFG.LABEL_PREFIX))
		logger.log(f"connected to {db.dbpath}.")

	except apsw.CantOpenError:
		logger.log("error.")
		logger.log(("Unable to open/create database file: check mountpoint exists + "
			"permissions (Sugg. fixes: Check mountpoint defined in "
			"/etc/catalis/global.conf and consult with your system "
			"administrator)."), level=Logger.FATAL)
		logger.log(e, level=Logger.TRACE)
		
		exit_fatal(logger)


	# initialize TCP connection
	hmi = ModbusClient(host=CFG.HMI_HOST, timeout=CFG.POLLING_FREQ)

	pdef = PacketDefinition(type="report", addresses=[2000, 2001, 2002])


	# main loop
	pollcount = 1
	while True:
		# poll for data
		logger.log(f"(poll~{pollcount}) <1/2>: Polling HMI for packet type: \"{pdef.type}\"... ", endline=False)
		
		while True:			
			try:
				data = poll(hmi, definition=pdef)
				logger.log(f"read {len(data)} registers.")
				break
			
			except TypeError: # on failure, retry...
				logger.log("error.")
				logger.log(f"No data received from link. Retrying in {CFG.POLL_RETRY_INT}s... ", level=Logger.ERROR, endline=False)

				sleep(int(CFG.POLL_RETRY_INT))


		# write data to database
		logger.log(f"(poll~{pollcount}) <2/2>: Writing to database... ", endline=False)

		try: 
			db.write(type=pdef.type, data=json.dumps(data))
			logger.log("written.")

			pollcount += 1
			sleep(int(CFG.POLLING_FREQ))

		# on failure, throw fatal error...
		except (apsw.ReadOnlyError, apsw.CantOpenError) as e:
			logger.log("error.")
			logger.log(f"Failed while writing to database - ", level=Logger.FATAL, endline=False)

			if isinstance(e, apsw.ReadOnlyError): logger.log("check mounted filesytem permissions ", endline=False)
			elif isinstance(e, apsw.CantOpenError): logger.log("ensure local DB has not been deleted ", endline=False)			
			
			logger.log("(Sugg. fixes: Try re-inserting the storage volume).")
			logger.log(e, level=Logger.TRACE)
			
			exit_fatal(logger)


# ================================================================ EXIT HANDLERS


# custom clean exit handler
def exit_clean(logger:Logger, signum:int, frame:FrameType) -> None:
	logger.print(f"\nTerminated cleanly at {strftime('%T', gmtime())}.")
	sh.run(f"echo 'Daemon exiting cleanly.'", shell=True) # write to journalctl log
	sys.exit(0)


# custom error exit handler
def exit_fatal(logger:Logger) -> None:
	logger.print(f"\nTerminated due to fatal error at {strftime('%T', gmtime())}.")
	sh.run(f"echo 'Daemon exiting with fatal error. Check log: {logger}'", shell=True) # write to journalctl log
	sys.exit(1)


# ================================================================== DRIVER CODE


# driver
if __name__ == "__main__":
	daemon()