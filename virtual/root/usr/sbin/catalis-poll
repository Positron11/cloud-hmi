#!/home/aarush/Documents/Projects/CloudHMI/virtual/bin/python

# ======================================================= IMPORTS & MODULE SETUP


import os
import sys
import json
import signal
import subprocess as sh
from types import FrameType
from time import sleep, strftime, gmtime
from pyModbusTCP.client import ModbusClient
import apsw, apsw.bestpractice


# initialize apsw
apsw.bestpractice.apply((
	apsw.bestpractice.connection_busy_timeout,
	apsw.bestpractice.connection_enable_foreign_keys,
	apsw.bestpractice.connection_dqs
))


# ================================================================ GLOBALS SETUP


# structure class for dict -> obj
class Struct:
	def __init__(self, **entries):
		self.__dict__.update(entries)

# create config object
CFG = Struct(**os.environ)


# set logfile
logfile = f"/var/log/catalis/poll-{strftime('%d%m%Y-%H%M%S', gmtime())}.log"


# get filesytem label and device id
fs_label = sh.getoutput(f"lsblk -o label /dev/{sys.argv[1]} | tail -1")
hmid = fs_label.strip(CFG.LABEL_PREFIX)


# ====================================================================== LOGGING


# write to log
def log(string:str, level:int=3, newline=False, endline:bool=True) -> None:
	levels = [ # log entry level labels
		"[fatal] ", "[error] ", "[warn] ", 
		"[info] ", "[debug] ", "[trace] ", ""
	]

	with open(logfile, "a+") as f:
		# get last char (if possible) to check if previous entry terminated
		try: 
			f.seek(f.tell() - 1, os.SEEK_SET)
			prevterm = f.read(1) in ["\n", ""]
		
		except: # beginning of file 
			prevterm = True

		# prepend timestamp and level if last char newline (ie. this is a new entry)
		if newline or prevterm: out = f"""{strftime("%T", gmtime())} | {levels[level]}{string}"""
		else: out = f"""{string}"""
		
		# append newline if log entry is completed, prepend if specified
		if newline and not prevterm: out = "\n" + out
		print(out, end="\n" if endline else "", file=f)


# ========================================================== DATABASE OPERATIONS


# initialize database
def init_db(hmid:str) -> apsw.Connection:
	try: 
		# try to connect to database
		log("Init (1/2): Connecting to database... ", endline=False)
		
		# create db subdirectory
		subdir = "current"
		sh.run(f"mkdir -p {CFG.MOUNTPOINT}/{subdir}", shell=True)

		dbpath = f"{CFG.MOUNTPOINT}/{subdir}/polldata-hmi{hmid}.sqlite3"
		exists = int(sh.getoutput(f"test -f {dbpath} && echo 1 || echo 0"))
		connection = apsw.Connection(dbpath)
		
		log(f"{'connected to' if exists else 'created'} {dbpath}.")

		# try to initialize database
		log("Init (2/2): Initializing database... ", endline=False)
		
		connection.execute("""CREATE TABLE IF NOT EXISTS polls(
					 id INTEGER PRIMARY KEY,
					 timestamp TEXT NOT NULL UNIQUE,
					 type TEXT NOT NULL,
					 data TEXT NOT NULL
		);""")
		
		log("done.")
	
	except Exception as e:	# failed to initialize database
		log("error.")
		log(("Unable to open/create database file: check mountpoint exists + "
	   		 "permissions (Sugg. fixes: Check mountpoint defined in "
			 "/etc/catalis/global.conf and consult with your system "
			 "administrator)."), level=0)
		log(e, level=5)
		exit_ferror()

	return connection


# write poll data to database
def write_db(db:apsw.Connection, type:str, data:str) -> None:
	log(f"Writing to database... ", endline=False)

	try:
		timestamp = strftime("%s", gmtime())
		db.execute("INSERT INTO polls(timestamp, type, data) VALUES(?,?,?);", (timestamp, type, data))
		log("written.")

	# failed to write to database
	except Exception as e0:
		e = e0 # set exception to general exception

		log("error.")
		log(f"Failed while writing to database: ", level=0, endline=False)
		
		try: # check if can open db, if yes assume permissions error
			test = apsw.Connection(f"{CFG.MOUNTPOINT}/polldata-hmi{hmid}.sqlite3", flags=apsw.SQLITE_OPEN_READWRITE)
			log("check mounted filesytem permissions ", endline=0)
			
		except Exception as e1: # otherwise, assume database deleted
			e = e1 # make exception more specific

			log("ensure local DB has not been deleted ", endline=0)

		log("(Sugg. fixes: Try re-inserting the storage volume).")
		log(e, level=5)
		exit_ferror()


# ================================================================== MAIN DAEMON


# daemon
def daemon() -> None:
	# write to journalctl log
	sh.run(f"echo 'Daemon started. Logging to {logfile}.'", shell=True)

	# initial information
	log(f"Welcome to the Catalis Cloud HMI Poller Daemon", level=6)
	log(f"Session date: {strftime('%F', gmtime())} (GMT)", level=6)
	log(f"Filesystem label: {fs_label}", level=6)
	log(f"Mount point: {CFG.MOUNTPOINT}", level=6)
	log(f"HMI TCP/IP host addr.: {CFG.MOUNTPOINT}", level=6)

	# initialize + get database connection
	db = init_db(hmid)

	# initialize TCP connection
	try:
		client = ModbusClient(host=CFG.HMI_HOST, timeout=CFG.POLL_INTERVAL)
	
	except Exception as e:
		log("Unable to initialize MODBUS TCP connection (Sugg. fixes: Consult with system administrator).", level=0)
		log(e, level=5)
		exit_ferror()

	# main loop
	pc = 1
	while True:
		log(f"Poll #{pc} (1/2): Polling HMI registers... ", endline=False)

		retried = False
		while True:
			data = client.read_holding_registers(2000, 1)
			
			if data: 
				log("recieved.")
				packet = {"addr2000": data[0]}

				log(f"Poll #{pc} (2/2): ", endline=False)
				write_db(db, "generic", json.dumps(packet))

				pc += 1
				break
			
			else: 
				log("error.")
				log(f"No data received from link. Retrying in {CFG.RETRY_INTERVAL}s...", level=1, endline=False)

			sleep(int(CFG.RETRY_INTERVAL))

		sleep(int(CFG.POLL_INTERVAL))


# ================================================================ EXIT HANDLERS


# custom clean exit handler
def exit_clean(signum:int, frame:FrameType) -> None:
	sh.run(f"echo 'Daemon exiting cleanly.'", shell=True) # write to journalctl log
	log(f"Terminating daemon cleanly.", level=6, newline=True)
	exit(0) # exit with success


# custom clean exit handler
def exit_ferror() -> None:
	sh.run(f"echo 'Daemon exiting with fatal error. Check log: {logfile}'", shell=True) # write to journalctl log
	log(f"Terminating due to fatal error.", level=6, newline=True)
	exit(1) # exit with error


# ================================================================== DRIVER CODE


# register custom standard termination exit handler
signal.signal(signal.SIGTERM, exit_clean)

# driver
if __name__ == "__main__":
	daemon()