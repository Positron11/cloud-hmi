#!/bin/python

# ======================================================= IMPORTS & MODULE SETUP


import os
import sys
import signal
import subprocess as sh
from types import FrameType
from functools import partial

from CatalisLogger.logging import Logger

import json
from time import sleep, strftime, gmtime
import apsw, apsw.bestpractice
from pyModbusTCP.client import ModbusClient


# initialize apsw
apsw.bestpractice.apply((
	apsw.bestpractice.connection_busy_timeout,
	apsw.bestpractice.connection_enable_foreign_keys,
	apsw.bestpractice.connection_dqs
))


# ================================================================= CONFIG SETUP


# create config object
class CFG:
	FSTYPE 					= os.environ.get("CATALIS_FSTYPE", 					"vfat")
	LABEL_PREFIX 			= os.environ.get("CATALIS_LABEL_PREFIX", 			"DATA-HMI")
	MOUNTPOINT 				= os.environ.get("CATALIS_MOUNTPOINT", 				"/srv/CatalisDATA/")
	DB_SUBDIR 				= os.environ.get("CATALIS_DB_SUBDIR", 				"current/")
	DB_PATTERN 				= os.environ.get("CATALIS_DB_PATTERN", 				"polldata-hmi$HMID")
	HMI_HOST 				= os.environ.get("CATALIS_HMI_HOST", 				"192.168.1.2")
	POLLING_FREQUENCY 		= os.environ.get("CATALIS_POLLING_FREQUENCY", 		"5")
	POLL_RETRY_INTERVAL 	= os.environ.get("CATALIS_POLL_RETRY_INTERVAL", 	"10")


# ================================================================= DATA PACKETS


# data packet definition class
class PacketDefinition:
	def __init__(self, type:str, addresses:list[str]):
		self.type = type
		self.addresses = addresses


# =========================================================== POLL DATA DATABASE


class PollDB:
	def __init__(self, hmid:str):
		self.basepath = os.path.join(CFG.MOUNTPOINT, CFG.DB_SUBDIR)
		self.dbpath =  os.path.join(self.basepath, (f"{CFG.DB_PATTERN}.sqlite3").replace("$HMID", hmid))
		self.connection = None

	
	# initialize database
	def initialize(self, logger:Logger) -> None:
		try: 
			# try to connect to database
			logger.log("Init (1/2): Connecting to database... ", endline=False)
			
			# create db subdirectory
			os.makedirs(self.basepath, exist_ok=True)

			# initialize connection
			exists = int(sh.getoutput(f"test -f {self.dbpath} && echo 1 || echo 0"))
			self.connection = apsw.Connection(self.dbpath)
			logger.log(f"{'connected to' if exists else 'created'} {self.connection.filename}.")

			# try to initialize database
			logger.log("Init (2/2): Initializing database... ", endline=False)
	
			self.connection.execute("""CREATE TABLE IF NOT EXISTS polls(
						id INTEGER PRIMARY KEY,
						timestamp TEXT NOT NULL UNIQUE,
						type TEXT NOT NULL,
						data TEXT NOT NULL
			);""")
			
			logger.log("done.")
		
		except apsw.CantOpenError as e:	# failed to initialize database
			logger.log("error.")
			logger.log(("Unable to open/create database file: check mountpoint exists + "
				"permissions (Sugg. fixes: Check mountpoint defined in "
				"/etc/catalis/global.conf and consult with your system "
				"administrator)."), level=Logger.FATAL)
			logger.log(e, level=Logger.TRACE)
			
			exit_fatal(logger)


	# write poll data to database
	def write(self, type:str, data:str, logger:Logger) -> None:
		logger.log(f"Writing to database... ", endline=False)

		try:
			timestamp = strftime("%s", gmtime())
			self.connection.execute("INSERT INTO polls(timestamp, type, data) VALUES(?,?,?);", (timestamp, type, data))
			logger.log("written.")

		# failed to write to database
		except apsw.ReadOnlyError as e0:
			e = e0 # set exception to general exception
			logger.log("error.")
			logger.log(f"Failed while writing to database: ", level=Logger.FATAL, endline=False)
			
			try: # check if can open db, if yes assume permissions error
				test = apsw.Connection(self.connection.filename, flags=apsw.SQLITE_OPEN_READWRITE)
				logger.log("check mounted filesytem permissions ", endline=0)
				
			except apsw.CantOpenError as e1: # otherwise, assume database deleted
				e = e1 # make exception more specific
				logger.log("ensure local DB has not been deleted ", endline=0)

			logger.log("(Sugg. fixes: Try re-inserting the storage volume).")
			logger.log(e, level=Logger.TRACE)
			
			exit_fatal(logger)


# ====================================================================== POLLING


def poll(client:ModbusClient, addresses:list[str], logger:Logger) -> dict:
	logger.log(f"Polling HMI registers... ", endline=False)

	# try until successful
	while True:
		try: 
			data = {str(addr):client.read_holding_registers(addr)[0] for addr in addresses}
			logger.log("recieved.")
			break
		
		except TypeError: # if None value exists in data (ie. failed to retrieve a register)
			logger.log("error.")
			logger.log(f"No data received from link. Retrying in {CFG.POLL_RETRY_INTERVAL}s...", level=Logger.ERROR, endline=False)

		sleep(int(CFG.POLL_RETRY_INTERVAL))

	return data


# ================================================================== MAIN DAEMON


# daemon
def daemon() -> None:
	# get filesytem label and device id
	fs_label = sh.getoutput(f"lsblk -o label /dev/{sys.argv[1]} | tail -1")
	hmid = fs_label.strip(CFG.LABEL_PREFIX)

	# initialize logger 
	logger = Logger(logfile=f"/var/log/catalis/poll-{strftime('%d%m%Y-%H%M%S', gmtime())}.log")

	# register custom standard termination exit handler
	signal.signal(signal.SIGTERM, partial(exit_clean, logger))

	# write to journalctl log
	sh.run(f"echo 'Daemon started. Logging to {logger}.'", shell=True)

	# initial information
	logger.print(f"Welcome to the Catalis Cloud HMI Poller Daemon")
	logger.print(f"Session date: {strftime('%F', gmtime())} (GMT)")
	logger.print(f"Filesystem label: {fs_label}")
	logger.print(f"Mount point: {CFG.MOUNTPOINT}")
	logger.print(f"HMI TCP/IP host address: {CFG.HMI_HOST}\n")

	# initialize database
	db = PollDB(hmid=hmid)
	db.initialize(logger=logger)

	# initialize TCP connection
	hmi = ModbusClient(host=CFG.HMI_HOST, timeout=CFG.POLLING_FREQUENCY)

	pdef = PacketDefinition(type="report", addresses=[2000, 2001, 2002])

	# main loop
	pc = 1
	while True:
		# poll for data
		logger.log(f"Poll #{pc} (1/2): ", endline=False)
		data = poll(hmi, addresses=pdef.addresses, logger=logger)

		# write data to db
		logger.log(f"Poll #{pc} (2/2): ", endline=False)
		db.write(type=pdef.type, data=json.dumps(data), logger=logger)
		
		pc += 1
		sleep(int(CFG.POLLING_FREQUENCY))


# ================================================================ EXIT HANDLERS


# custom clean exit handler
def exit_clean(logger:Logger, signum:int, frame:FrameType) -> None:
	logger.print(f"\nTerminated cleanly at {strftime('%T', gmtime())}.")
	logger.close()

	sh.run(f"echo 'Daemon exiting cleanly.'", shell=True) # write to journalctl log
	sys.exit(0)


# custom error exit handler
def exit_fatal(logger:Logger) -> None:
	logger.print(f"\nTerminated due to fatal error at {strftime('%T', gmtime())}.")
	logger.close()

	sh.run(f"echo 'Daemon exiting with fatal error. Check log: {logger}'", shell=True) # write to journalctl log
	sys.exit(1)


# ================================================================== DRIVER CODE


# driver
if __name__ == "__main__":
	daemon()