#!/bin/python

# ======================================================= IMPORTS & MODULE SETUP


import os
import sys
import signal
import subprocess as sh
from types import FrameType
from functools import partial

import json
from time import sleep, strftime, gmtime
import apsw, apsw.bestpractice
from pyModbusTCP.client import ModbusClient


# initialize apsw
apsw.bestpractice.apply((
	apsw.bestpractice.connection_busy_timeout,
	apsw.bestpractice.connection_enable_foreign_keys,
	apsw.bestpractice.connection_dqs
))


# ================================================================= CONFIG SETUP


# structure class for dict -> obj
class Struct:
	def __init__(self, **entries):
		self.__dict__.update(entries)

# create config object
CFG = Struct(**os.environ)


# ====================================================================== LOGGING


class Logger:
	levels = [ # log entry level labels
		"[fatal] ", "[error] ", "[warn] ", 
		"[info] ", "[debug] ", "[trace] ", ""
	]


	# constructor
	def __init__(self, logfile:str):
		self.logfile = open(logfile, "a+")


	# get open logfile path
	def __str__(self):
		return self.logfile.name	


	# logging function
	def log(self, string:str, level:int=3, newline=False, endline:bool=True) -> None:
		# get last char (if possible) to check if previous entry terminated
		try: 
			self.logfile.seek(self.logfile.tell() - 1, os.SEEK_SET)
			prevterm = self.logfile.read(1) in ["\n", ""]
		
		except: # beginning of file 
			prevterm = True

		# prepend timestamp and level if last char newline (ie. this is a new entry)
		if newline or prevterm: out = f"""{strftime("%T", gmtime())} | {self.levels[level]}{string}"""
		else: out = f"""{string}"""
		
		# append newline if log entry is completed, prepend if specified
		if newline and not prevterm: out = "\n" + out
		print(out, end="\n" if endline else "", file=self.logfile)


	# close logfile
	def close(self) -> None:
		self.logfile.close()


# ================================================================= DATA PACKETS

# data packet definition class
class PacketDefinition:
	def __init__(self, type:str, addresses:list):
		self.type = type
		self.addresses = addresses

# ========================================================== DATABASE OPERATIONS


# initialize database
def init_db(hmid:str, logger:Logger) -> apsw.Connection:
	try: 
		# try to connect to database
		logger.log("Init (1/2): Connecting to database... ", endline=False)
		
		# create db subdirectory
		subdir = "current"
		sh.run(f"mkdir -p {CFG.MOUNTPOINT}/{subdir}", shell=True)

		dbpath = f"{CFG.MOUNTPOINT}/{subdir}/polldata-hmi{hmid}.sqlite3"
		exists = int(sh.getoutput(f"test -f {dbpath} && echo 1 || echo 0"))
		connection = apsw.Connection(dbpath)
		
		logger.log(f"{'connected to' if exists else 'created'} {dbpath}.")

		# try to initialize database
		logger.log("Init (2/2): Initializing database... ", endline=False)
		
		connection.execute("""CREATE TABLE IF NOT EXISTS polls(
					 id INTEGER PRIMARY KEY,
					 timestamp TEXT NOT NULL UNIQUE,
					 type TEXT NOT NULL,
					 data TEXT NOT NULL
		);""")
		
		logger.log("done.")
	
	except Exception as e:	# failed to initialize database
		logger.log("error.")
		logger.log(("Unable to open/create database file: check mountpoint exists + "
	   		 "permissions (Sugg. fixes: Check mountpoint defined in "
			 "/etc/catalis/global.conf and consult with your system "
			 "administrator)."), level=0)
		logger.log(e, level=5)
		
		exit_fatal(logger)

	return connection


# write poll data to database
def write_db(db:apsw.Connection, type:str, data:str, logger:Logger) -> None:
	logger.log(f"Writing to database... ", endline=False)

	try:
		timestamp = strftime("%s", gmtime())
		db.execute("INSERT INTO polls(timestamp, type, data) VALUES(?,?,?);", (timestamp, type, data))
		logger.log("written.")

	# failed to write to database
	except Exception as e0:
		e = e0 # set exception to general exception
		logger.log("error.")
		logger.log(f"Failed while writing to database: ", level=0, endline=False)
		
		try: # check if can open db, if yes assume permissions error
			test = apsw.Connection(db.filename, flags=apsw.SQLITE_OPEN_READWRITE)
			logger.log("check mounted filesytem permissions ", endline=0)
			
		except Exception as e1: # otherwise, assume database deleted
			e = e1 # make exception more specific
			logger.log("ensure local DB has not been deleted ", endline=0)

		logger.log("(Sugg. fixes: Try re-inserting the storage volume).")
		logger.log(e, level=5)
		
		exit_fatal(logger)


# ====================================================================== POLLING


def poll(client:ModbusClient, addresses:list, logger:Logger) -> dict:
	logger.log(f"Polling HMI registers... ", endline=False)

	# try until successful
	while True:
		try: 
			data = {str(addr):client.read_holding_registers(addr)[0] for addr in addresses}
			logger.log("recieved.")
			break
		
		except: 
			logger.log("error.")
			logger.log(f"No data received from link. Retrying in {CFG.RETRY_INTERVAL}s...", level=1, endline=False)

		sleep(int(CFG.RETRY_INTERVAL))

	return data


# ================================================================== MAIN DAEMON


# daemon
def daemon() -> None:
	# get filesytem label and device id
	fs_label = sh.getoutput(f"lsblk -o label /dev/{sys.argv[1]} | tail -1")
	hmid = fs_label.strip(CFG.LABEL_PREFIX)

	# register custom standard termination exit handler
	signal.signal(signal.SIGTERM, partial(exit_clean, logger))

	# initialize logger
	logger = Logger(f"/var/log/catalis/poll-{strftime('%d%m%Y-%H%M%S', gmtime())}.log")

	# write to journalctl log
	sh.run(f"echo 'Daemon started. Logging to {logger}.'", shell=True)

	# initial information
	logger.log(f"Welcome to the Catalis Cloud HMI Poller Daemon", level=6)
	logger.log(f"Session date: {strftime('%F', gmtime())} (GMT)", level=6)
	logger.log(f"Filesystem label: {fs_label}", level=6)
	logger.log(f"Mount point: {CFG.MOUNTPOINT}", level=6)
	logger.log(f"HMI TCP/IP host addr.: {CFG.MOUNTPOINT}", level=6)

	# initialize + get database connection
	db = init_db(logger=logger, hmid=hmid)

	# initialize TCP connection
	try:
		hmi = ModbusClient(host=CFG.HMI_HOST, timeout=CFG.POLL_INTERVAL)

	except Exception as e:
		logger.log("Unable to initialize MODBUS TCP connection (Sugg. fixes: Consult with system administrator).", level=0)
		logger.log(e, level=5)
		
		exit_fatal(logger)

	pdef = PacketDefinition(type="report", addresses=[0, 1, 2])

	# main loop
	pc = 1
	while True:
		# poll for data
		logger.log(f"Poll #{pc} (1/2): ", endline=False)
		data = poll(hmi, addresses=pdef.addresses, logger=logger)

		# write data to db
		logger.log(f"Poll #{pc} (2/2): ", endline=False)
		write_db(db=db, type=pdef.type, data=json.dumps(data), logger=logger)
		
		pc += 1
		sleep(int(CFG.POLL_INTERVAL))


# ================================================================ EXIT HANDLERS


# Raise SIGTERM again to trigger the default handler
def default_sigterm_handler():
	signal.signal(signal.SIGTERM, signal.SIG_DFL)
	os.kill(os.getpid(), signal.SIGTERM)


# custom clean exit handler
def exit_clean(logger:Logger, signum:int, frame:FrameType) -> None:
	sh.run(f"echo 'Daemon exiting cleanly.'", shell=True) # write to journalctl log
	
	logger.log(f"Terminating daemon cleanly.", level=6, newline=True)
	logger.close()
	
	default_sigterm_handler()


# custom error exit handler
def exit_fatal(logger:Logger) -> None:
	sh.run(f"echo 'Daemon exiting with fatal error. Check log: {logger}'", shell=True) # write to journalctl log
	
	logger.log(f"Terminating due to fatal error.", level=6, newline=True)
	logger.close()

	default_sigterm_handler()


# ================================================================== DRIVER CODE


# driver
if __name__ == "__main__":
	daemon()