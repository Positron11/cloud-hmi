#!/bin/python

# ======================================================= IMPORTS & MODULE SETUP


import os
import sys
import signal
import subprocess as sh
from types import FrameType
from functools import partial

from CatalisUtils.logging import Logger
from CatalisUtils.database import CatalisDB, busy_handler

import json
from time import sleep, strftime, gmtime, time
import apsw, apsw.bestpractice
from pyModbusTCP.client import ModbusClient
from configparser import RawConfigParser


# initialize apsw
apsw.bestpractice.apply((
	apsw.bestpractice.connection_busy_timeout,
	apsw.bestpractice.connection_enable_foreign_keys,
	apsw.bestpractice.connection_dqs
))


# ================================================================= CONFIG SETUP


# create config object
class CFG:
	FSTYPE 			= os.environ.get("CATALIS_FSTYPE", 					"vfat")
	LABEL_PREFIX 	= os.environ.get("CATALIS_LABEL_PREFIX", 			"DATA-HMI")
	MOUNTPOINT 		= os.environ.get("CATALIS_MOUNTPOINT", 				"/srv/CatalisDATA/")
	DB_SUBDIR 		= os.environ.get("CATALIS_DB_SUBDIR", 				"current/")
	DB_PATTERN 		= os.environ.get("CATALIS_DB_PATTERN", 				"polldata-hmi$HMID")
	HMI_HOST 		= os.environ.get("CATALIS_HMI_HOST", 				"192.168.1.2")
	BUSY_RETRY_INT 	= os.environ.get("CATALIS_DB_BUSY_RETRY_INTERVAL", 	"10")
	POLLING_FREQ 	= os.environ.get("CATALIS_POLLING_FREQUENCY", 		"5")
	POLL_RETRY_INT 	= os.environ.get("CATALIS_POLL_RETRY_INTERVAL", 	"10")


# ================================================================= DATA PACKETS


# data packet definition class
class PacketDefinition():
	def __init__(self, type:str, frequency:int, addresses:list[int]) -> None:
		self.type = type
		self.frequency = frequency
		self.addresses = addresses
		self.lastpolled = -1 # poll immediately at startup


# ====================================================================== POLLING
 

def poll(client:ModbusClient, addresses:list[int]) -> dict:
	try: return {str(addr):client.read_holding_registers(addr)[0] for addr in addresses}
	except TypeError as e: raise e # if None value exists in data (ie. failed to retrieve a register)


# ================================================================== MAIN DAEMON


# daemon
def daemon() -> None:
	# initialize logger 
	logger = Logger(logfile=f"/var/log/catalis/poll-{strftime('%d%m%Y-%H%M%S', gmtime())}.log")

	# register custom standard termination exit handler
	signal.signal(signal.SIGTERM, partial(exit_clean, logger))

	# write to journalctl log
	sh.run(f"echo 'Daemon started. Logging to {logger}.'", shell=True)

	# get filesytem label
	fs_label = sh.getoutput(f"lsblk -o label /dev/{sys.argv[1]} | tail -1")

	# print logging preamble
	logger.print(f"Welcome to the Catalis Cloud HMI Poller Daemon")
	logger.print(f"Session date: {strftime('%F', gmtime())} (GMT)")
	logger.print(f"Filesystem label: {fs_label}")
	logger.print(f"Mount point: {CFG.MOUNTPOINT}")
	logger.print(f"HMI TCP/IP host address: {CFG.HMI_HOST}\n")


	# initialize database connection
	logger.log("(init) <1/2>: Connecting to database... ", endline=False)

	try:
		hmid = fs_label.strip(CFG.LABEL_PREFIX) 
		dbpath =  os.path.join(CFG.MOUNTPOINT, CFG.DB_SUBDIR, (f"{CFG.DB_PATTERN}.sqlite3").replace("$HMID", hmid))
		
		db = CatalisDB(dbpath)
		db._connection.set_busy_handler(partial(busy_handler, logger, int(CFG.BUSY_RETRY_INT)))
		
		logger.log(f"connected to {db._connection.db_filename}.")

	except apsw.CantOpenError as e:
		logger.log("error.")
		logger.log(("Unable to open/create database file: check mountpoint "
			  		"exists + permissions (Sugg. fixes: Check mountpoint defined "
					"in /etc/catalis/global.conf and consult with your system "
					"administrator)."), level=Logger.FATAL)
		logger.log(e, level=Logger.TRACE)

		exit_fatal(logger)


	# initialize TCP connection
	hmi = ModbusClient(host=CFG.HMI_HOST, timeout=CFG.POLLING_FREQ)


	# load packet definitions
	parser = RawConfigParser()
	parser.read("/etc/catalis/packet.conf")
	
	packet_defs = [
		PacketDefinition(
			type=definition,
			frequency=int(parser.get(definition, "Frequency")),
			addresses=[int(x) for x in parser.get(definition, "Addresses").split(",")]
		) 
		for definition in parser.sections()
	]


	# main loop
	groupcount = 1
	groupstart = False
	
	while True:
		for packet in packet_defs:
			if (pollstart := int(time())) - packet.lastpolled > packet.frequency:
				# print visual separator
				if not groupstart: 
					logger.print("---------|")
					groupstart = True


				# poll for data
				logger.log(f"(poll~g{groupcount:03}) <1/2>: Polling HMI for packet type: \"{packet.type}\"... ", endline=False)
				
				while True:			
					try:
						data = poll(hmi, addresses=packet.addresses)
						logger.log(f"read {len(data)} registers.")
						break
					
					except TypeError: # on failure, retry...
						logger.log("error.")
						logger.log(f"No data received from link. Retrying in {CFG.POLL_RETRY_INT}s... ", level=Logger.ERROR, endline=False)

						sleep(int(CFG.POLL_RETRY_INT))


				# write data to database
				logger.log(f"(poll~g{groupcount:03}) <2/2>: Writing to database... ", endline=False)

				try: 
					timestamp = strftime("%s", gmtime())
					db.execute("INSERT INTO packets (timestamp, type, data) VALUES (?,?,?);", (timestamp, packet.type, json.dumps(data)), logger=logger)
					logger.log("written.")
					packet.lastpolled = pollstart

				# on failure, throw fatal error...
				except (apsw.ReadOnlyError, apsw.CantOpenError) as e:
					exit_fatal(logger)


		# increment pollgroup count
		if groupstart: 
			groupcount += 1
			groupstart = False

		sleep(int(CFG.POLLING_FREQ))


# ================================================================ EXIT HANDLERS


# custom clean exit handler
def exit_clean(logger:Logger, signum:int, frame:FrameType) -> None:
	logger.print(f"\nTerminated cleanly at {strftime('%T', gmtime())}.")
	sh.run(f"echo 'Daemon exiting cleanly.'", shell=True) # write to journalctl log
	sys.exit(0)


# custom error exit handler
def exit_fatal(logger:Logger) -> None:
	logger.print(f"\nTerminated due to fatal error at {strftime('%T', gmtime())}.")
	sh.run(f"echo 'Daemon exiting with fatal error. Check log: {logger}'", shell=True) # write to journalctl log
	sys.exit(1)


# ================================================================== DRIVER CODE


# driver
if __name__ == "__main__":
	daemon()