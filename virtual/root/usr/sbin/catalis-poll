#!/bin/python

# ======================================================= IMPORTS & MODULE SETUP


import os
import sys
import signal
import subprocess as sh
from types import FrameType
from functools import partial

from CatalisLogger.logging import Logger

import json
from time import sleep, strftime, gmtime, time
import apsw, apsw.bestpractice
from pyModbusTCP.client import ModbusClient
from configparser import RawConfigParser


# initialize apsw
apsw.bestpractice.apply((
	apsw.bestpractice.connection_busy_timeout,
	apsw.bestpractice.connection_enable_foreign_keys,
	apsw.bestpractice.connection_dqs
))


# ================================================================= CONFIG SETUP


# create config object
class CFG:
	FSTYPE 			= os.environ.get("CATALIS_FSTYPE", 					"vfat")
	LABEL_PREFIX 	= os.environ.get("CATALIS_LABEL_PREFIX", 			"DATA-HMI")
	MOUNTPOINT 		= os.environ.get("CATALIS_MOUNTPOINT", 				"/srv/CatalisDATA/")
	DB_SUBDIR 		= os.environ.get("CATALIS_DB_SUBDIR", 				"current/")
	DB_PATTERN 		= os.environ.get("CATALIS_DB_PATTERN", 				"polldata-hmi$HMID")
	HMI_HOST 		= os.environ.get("CATALIS_HMI_HOST", 				"192.168.1.2")
	BUSY_RETRY_INT 	= os.environ.get("CATALIS_DB_BUSY_RETRY_INTERVAL", 	"10")
	POLLING_FREQ 	= os.environ.get("CATALIS_POLLING_FREQUENCY", 		"5")
	POLL_RETRY_INT 	= os.environ.get("CATALIS_POLL_RETRY_INTERVAL", 	"10")


# ================================================================= DATA PACKETS


# data packet definition class
class PacketDefinition():
	def __init__(self, type:str, frequency:int, addresses:list[int]) -> None:
		self.type = type
		self.frequency = frequency
		self.addresses = addresses
		self.lastpolled = -1 # poll immediately at startup


# =================================================== POLL DATA DATABASE MANAGER


class PollDB:
	def __init__(self, hmid:str) -> None:
		self.dbpath =  os.path.join(CFG.MOUNTPOINT, CFG.DB_SUBDIR, (f"{CFG.DB_PATTERN}.sqlite3").replace("$HMID", hmid))
		
		try: self._connection = apsw.Connection(self.dbpath)		
		except apsw.CantOpenError as e: raise e # failed to initialize database


	# write poll data to database
	def write(self, type:str, data:str) -> None:
		try:
			timestamp = strftime("%s", gmtime())
			self._connection.execute("INSERT INTO packets (timestamp, type, data) VALUES (?,?,?);", (timestamp, type, data))

		# failed to write to database
		except apsw.ReadOnlyError as e0:			
			try: # check if can open db, if yes assume permissions error
				test = apsw.Connection(self._connection.filename, flags=apsw.SQLITE_OPEN_READWRITE)
				raise e0
				
			except apsw.CantOpenError as e1: # otherwise, assume database deleted
				raise e1


# ====================================================================== POLLING
 

def poll(client:ModbusClient, addresses:list[int]) -> dict:
	try: return {str(addr):client.read_holding_registers(addr)[0] for addr in addresses}
	except TypeError as e: raise e # if None value exists in data (ie. failed to retrieve a register)


# ================================================================== MAIN DAEMON


# daemon
def daemon() -> None:
	# initialize logger 
	logger = Logger(logfile=f"/var/log/catalis/poll-{strftime('%d%m%Y-%H%M%S', gmtime())}.log")

	# register custom standard termination exit handler
	signal.signal(signal.SIGTERM, partial(exit_clean, logger))

	# write to journalctl log
	sh.run(f"echo 'Daemon started. Logging to {logger}.'", shell=True)

	# get filesytem label
	fs_label = sh.getoutput(f"lsblk -o label /dev/{sys.argv[1]} | tail -1")

	# print logging preamble
	logger.print(f"Welcome to the Catalis Cloud HMI Poller Daemon")
	logger.print(f"Session date: {strftime('%F', gmtime())} (GMT)")
	logger.print(f"Filesystem label: {fs_label}")
	logger.print(f"Mount point: {CFG.MOUNTPOINT}")
	logger.print(f"HMI TCP/IP host address: {CFG.HMI_HOST}\n")


	# initialize database connection
	logger.log("(init) <1/2>: Connecting to database... ", endline=False)

	try: 
		db = PollDB(hmid=fs_label.strip(CFG.LABEL_PREFIX))
		db._connection.set_busy_handler(partial(db_busy_handler, logger))
		logger.log(f"connected to {db.dbpath}.")

	except apsw.CantOpenError as e:
		logger.log("error.")
		logger.log(("Unable to open/create database file: check mountpoint exists + "
			"permissions (Sugg. fixes: Check mountpoint defined in "
			"/etc/catalis/global.conf and consult with your system "
			"administrator)."), level=Logger.FATAL)
		logger.log(e, level=Logger.TRACE)
		
		exit_fatal(logger)


	# initialize TCP connection
	hmi = ModbusClient(host=CFG.HMI_HOST, timeout=CFG.POLLING_FREQ)


	# load packet definitions
	parser = RawConfigParser()
	parser.read("/etc/catalis/packet.conf")
	
	packet_defs = [
		PacketDefinition(
			type=definition,
			frequency=int(parser.get(definition, "Frequency")),
			addresses=[int(x) for x in parser.get(definition, "Addresses").split(",")]
		) 
		for definition in parser.sections()
	]


	# main loop
	groupcount = 1
	groupstart = False
	
	while True:
		for packet in packet_defs:
			if (pollstart := int(time())) - packet.lastpolled > packet.frequency:
				# print visual separator
				if not groupstart: 
					logger.print("---------|")
					groupstart = True

				# poll for data
				logger.log(f"(poll~g{groupcount:03}) <1/2>: Polling HMI for packet type: \"{packet.type}\"... ", endline=False)
				
				while True:			
					try:
						data = poll(hmi, addresses=packet.addresses)
						logger.log(f"read {len(data)} registers.")
						break
					
					except TypeError: # on failure, retry...
						logger.log("error.")
						logger.log(f"No data received from link. Retrying in {CFG.POLL_RETRY_INT}s... ", level=Logger.ERROR, endline=False)

						sleep(int(CFG.POLL_RETRY_INT))


				# write data to database
				logger.log(f"(poll~g{groupcount:03}) <2/2>: Writing to database... ", endline=False)

				try: 
					db.write(type=packet.type, data=json.dumps(data))
					logger.log("written.")

					packet.lastpolled = pollstart

				# on failure, throw fatal error...
				except (apsw.ReadOnlyError, apsw.CantOpenError) as e:
					logger.log("error.")
					logger.log(f"Failed while writing to database - ", level=Logger.FATAL, endline=False)

					if isinstance(e, apsw.ReadOnlyError): logger.log("check mounted filesytem permissions ", endline=False)
					elif isinstance(e, apsw.CantOpenError): logger.log("ensure local DB has not been deleted ", endline=False)			
					
					logger.log("(Sugg. fixes: Try re-inserting the storage volume).")
					logger.log(e, level=Logger.TRACE)
					
					exit_fatal(logger)

		# increment pollgroup count
		if groupstart: 
			groupcount += 1
			groupstart = False

		sleep(int(CFG.POLLING_FREQ))


# ================================================================ EXIT HANDLERS


# sqlite db busy handler
def db_busy_handler(logger:Logger, priorcalls:int):
	logger.log(f"Database is busy - trying again in {CFG.BUSY_RETRY_INT}s... ", level=Logger.ERROR, endline=False)
	sleep(int(CFG.BUSY_RETRY_INT))
	return True


# custom clean exit handler
def exit_clean(logger:Logger, signum:int, frame:FrameType) -> None:
	logger.print(f"\nTerminated cleanly at {strftime('%T', gmtime())}.")
	sh.run(f"echo 'Daemon exiting cleanly.'", shell=True) # write to journalctl log
	sys.exit(0)


# custom error exit handler
def exit_fatal(logger:Logger) -> None:
	logger.print(f"\nTerminated due to fatal error at {strftime('%T', gmtime())}.")
	sh.run(f"echo 'Daemon exiting with fatal error. Check log: {logger}'", shell=True) # write to journalctl log
	sys.exit(1)


# ================================================================== DRIVER CODE


# driver
if __name__ == "__main__":
	daemon()