#!/bin/python

# ======================================================= IMPORTS & MODULE SETUP


import os
import sys
import signal
import subprocess as sh
from types import FrameType
from functools import partial

import json
from time import sleep, strftime, gmtime
import apsw, apsw.bestpractice
from pyModbusTCP.client import ModbusClient


# initialize apsw
apsw.bestpractice.apply((
	apsw.bestpractice.connection_busy_timeout,
	apsw.bestpractice.connection_enable_foreign_keys,
	apsw.bestpractice.connection_dqs
))


# ================================================================= CONFIG SETUP


# create config object
class CFG:
	FSTYPE 			= os.environ.get("CATALIS_FSTYPE", 			"vfat")
	LABEL_PREFIX 	= os.environ.get("CATALIS_LABEL_PREFIX", 	"DATA-HMI")
	MOUNTPOINT 		= os.environ.get("CATALIS_MOUNTPOINT", 		"/srv/CatalisDATA/")
	DB_SUBDIR 		= os.environ.get("CATALIS_DB_SUBDIR", 		"current/")
	DB_PATTERN 		= os.environ.get("CATALIS_DB_PATTERN", 		"polldata-hmi$HMID")
	HMI_HOST 		= os.environ.get("CATALIS_HMI_HOST", 		"192.168.1.2")
	POLL_INTERVAL 	= os.environ.get("CATALIS_POLL_INTERVAL", 	"5")
	RETRY_INTERVAL 	= os.environ.get("CATALIS_RETRY_INTERVAL", 	"5")


# ====================================================================== LOGGING


class Logger:
	# log entry levels
	FATAL, ERROR, WARN, INFO, DEBUG, TRACE, DEFAULT = range(7)
	levels = ["[fatal] ", "[error] ", "[warn] ", "[info] ", "[debug] ", "[trace] ", ""]


	# constructor
	def __init__(self, logfile:str):
		self.logfile = open(logfile, "a+")


	# get open logfile path
	def __str__(self):
		return self.logfile.name


	# check if the last line in the log is terminated
	def previous_line_terminated(self) -> bool:
		# get last char (if possible) to check if previous entry terminated
		try: 
			self.logfile.seek(self.logfile.tell() - 1, os.SEEK_SET)
			return self.logfile.read(1) in ["\n", ""]
		
		except: # beginning of file 
			return True


	# logging function
	def log(self, string:str, level:int=3, force_newline=False, endline:bool=True) -> None:
		is_newline = self.previous_line_terminated()
		
		# prepend timestamp and level if last char newline (ie. this is a new entry)
		if force_newline or is_newline: out = f"""{strftime("%T", gmtime())} | {self.levels[level]}{string}"""
		else: out = f"""{string}"""
		
		# append newline if log entry is completed, prepend if specified
		if force_newline and not is_newline: out = "\n" + out
		print(out, end="\n" if endline else "", file=self.logfile)


	# plain print to logfile
	def print(self, string:str):
		newline = "\n" * (not self.previous_line_terminated())
		print(f"""{newline}{string}""", file=self.logfile)


	# close logfile
	def close(self) -> None:
		self.logfile.close()


# ================================================================= DATA PACKETS


# data packet definition class
class PacketDefinition:
	def __init__(self, type:str, addresses:list):
		self.type = type
		self.addresses = addresses


# =========================================================== POLL DATA DATABASE


class PollDB:
	def __init__(self, hmid:str):
		self.basepath = os.path.join(CFG.MOUNTPOINT, CFG.DB_SUBDIR)
		self.dbpath =  os.path.join(self.basepath, (f"{CFG.DB_PATTERN}.sqlite3").replace("$HMID", hmid))
		self.connection = None

	
	# initialize database
	def initialize(self, logger:Logger) -> None:
		try: 
			# try to connect to database
			logger.log("Init (1/2): Connecting to database... ", endline=False)
			
			# create db subdirectory
			os.makedirs(self.basepath, exist_ok=True)

			# initialize connection
			exists = int(sh.getoutput(f"test -f {self.dbpath} && echo 1 || echo 0"))
			self.connection = apsw.Connection(self.dbpath)
			logger.log(f"{'connected to' if exists else 'created'} {self.connection.filename}.")

			# try to initialize database
			logger.log("Init (2/2): Initializing database... ", endline=False)
	
			self.connection.execute("""CREATE TABLE IF NOT EXISTS polls(
						id INTEGER PRIMARY KEY,
						timestamp TEXT NOT NULL UNIQUE,
						type TEXT NOT NULL,
						data TEXT NOT NULL
			);""")
			
			logger.log("done.")
		
		except apsw.CantOpenError as e:	# failed to initialize database
			logger.log("error.")
			logger.log(("Unable to open/create database file: check mountpoint exists + "
				"permissions (Sugg. fixes: Check mountpoint defined in "
				"/etc/catalis/global.conf and consult with your system "
				"administrator)."), level=Logger.FATAL)
			logger.log(e, level=Logger.TRACE)
			
			exit_fatal(logger)


	# write poll data to database
	def write(self, type:str, data:str, logger:Logger) -> None:
		logger.log(f"Writing to database... ", endline=False)

		try:
			timestamp = strftime("%s", gmtime())
			self.connection.execute("INSERT INTO polls(timestamp, type, data) VALUES(?,?,?);", (timestamp, type, data))
			logger.log("written.")

		# failed to write to database
		except apsw.ReadOnlyError as e0:
			e = e0 # set exception to general exception
			logger.log("error.")
			logger.log(f"Failed while writing to database: ", level=Logger.FATAL, endline=False)
			
			try: # check if can open db, if yes assume permissions error
				test = apsw.Connection(self.connection.filename, flags=apsw.SQLITE_OPEN_READWRITE)
				logger.log("check mounted filesytem permissions ", endline=0)
				
			except apsw.CantOpenError as e1: # otherwise, assume database deleted
				e = e1 # make exception more specific
				logger.log("ensure local DB has not been deleted ", endline=0)

			logger.log("(Sugg. fixes: Try re-inserting the storage volume).")
			logger.log(e, level=Logger.TRACE)
			
			exit_fatal(logger)


# ====================================================================== POLLING


def poll(client:ModbusClient, addresses:list, logger:Logger) -> dict:
	logger.log(f"Polling HMI registers... ", endline=False)

	# try until successful
	while True:
		try: 
			data = {str(addr):client.read_holding_registers(addr)[0] for addr in addresses}
			logger.log("recieved.")
			break
		
		except TypeError: # if None value exists in data (ie. failed to retrieve a register)
			logger.log("error.")
			logger.log(f"No data received from link. Retrying in {CFG.RETRY_INTERVAL}s...", level=Logger.ERROR, endline=False)

		sleep(int(CFG.RETRY_INTERVAL))

	return data


# ================================================================== MAIN DAEMON


# daemon
def daemon() -> None:
	# get filesytem label and device id
	fs_label = sh.getoutput(f"lsblk -o label /dev/{sys.argv[1]} | tail -1")
	hmid = fs_label.strip(CFG.LABEL_PREFIX)

	# initialize logger 
	logger = Logger(logfile=f"/var/log/catalis/poll-{strftime('%d%m%Y-%H%M%S', gmtime())}.log")

	# register custom standard termination exit handler
	signal.signal(signal.SIGTERM, partial(exit_clean, logger))

	# write to journalctl log
	sh.run(f"echo 'Daemon started. Logging to {logger}.'", shell=True)

	# initial information
	logger.print(f"Welcome to the Catalis Cloud HMI Poller Daemon")
	logger.print(f"Session date: {strftime('%F', gmtime())} (GMT)")
	logger.print(f"Filesystem label: {fs_label}")
	logger.print(f"Mount point: {CFG.MOUNTPOINT}")
	logger.print(f"HMI TCP/IP host address: {CFG.MOUNTPOINT}\n")

	# initialize database
	db = PollDB(hmid=hmid)
	db.initialize(logger=logger)

	# initialize TCP connection
	try:
		hmi = ModbusClient(host=CFG.HMI_HOST, timeout=CFG.POLL_INTERVAL)

	except Exception as e: # [todo) find and replace with actual exception
		logger.log("Unable to initialize MODBUS TCP connection (Sugg. fixes: Consult with system administrator).", level=Logger.FATAL)
		logger.log(e, level=Logger.TRACE)
		
		exit_fatal(logger)

	pdef = PacketDefinition(type="report", addresses=[2000, 2001, 2002])

	# main loop
	pc = 1
	while True:
		# poll for data
		logger.log(f"Poll #{pc} (1/2): ", endline=False)
		data = poll(hmi, addresses=pdef.addresses, logger=logger)

		# write data to db
		logger.log(f"Poll #{pc} (2/2): ", endline=False)
		db.write(type=pdef.type, data=json.dumps(data), logger=logger)
		
		pc += 1
		sleep(int(CFG.POLL_INTERVAL))


# ================================================================ EXIT HANDLERS


# custom clean exit handler
def exit_clean(logger:Logger, signum:int, frame:FrameType) -> None:
	logger.print(f"\nTerminated cleanly at {strftime('%T', gmtime())}.")
	logger.close()

	sh.run(f"echo 'Daemon exiting cleanly.'", shell=True) # write to journalctl log
	sys.exit(0)


# custom error exit handler
def exit_fatal(logger:Logger) -> None:
	logger.print(f"\nTerminated due to fatal error at {strftime('%T', gmtime())}.")
	logger.close()

	sh.run(f"echo 'Daemon exiting with fatal error. Check log: {logger}'", shell=True) # write to journalctl log
	sys.exit(1)


# ================================================================== DRIVER CODE


# driver
if __name__ == "__main__":
	daemon()